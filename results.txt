Fuzzing is  a time-consuming process. And I find many crashes the AFL found are repeated or the same. For example, in my AFL testing crashes, there are five test cases that cause the stack overflow crash. Well, I want to take back what I just said, because I found that the cause of the crash was due to a problem with my harness. I use scanf() to get inputs which will definitely cause the stack overflow crash. It's an interesting lesson for me.
And I find that if the seed is short in terms of number of characters, it can be mutated quickly and spend less time to find unique crashes compared with a seed that has many characters.  Even though the cycle counter turns green, it still can produce some unique crashes. So, I am not sure when to abort testing.
When I run the fuzzer with AFL and '-d', I can get quick and dirty results early compared with without using '-d' option. The reason why it can get instant results is because this mode causes afl-fuzz to skip all the deterministic fuzzing steps, but it will make the testing a bit less in-depth.
For libFuzzer, I think the AddressSanitizer is so powerful that can find crash quickly compared with only using fsanitize=fuzzer flag because I think it try to detect memory leaks. The crash is about heap buffer overflow. 
In addition, when I set the maximum length of test inputs to 64,the output tells me that libFuzzer has tried at least 67108864 inputs(#67108864), found 97 entries with a total of 35 kb(corp: 97/35Kb) and covered 16 edges(cov: 16). But when I set the -max_len to 256,  the libFuzzer has tries at least 107193035 inputs, and found 102 entries with a total of 36 kb and covered 16 edges. The difference between the different max string length is that the libFuzzerwhich has longer max length limitation will try more inputs but they have the same coverage.
